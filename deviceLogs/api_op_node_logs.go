// Package deviceLogs provides APIs to retrieve device-level
// log entries generated by nodes on the Anedya platform.
package deviceLogs

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/anedyaio/anedya-go-sdk/common"
	"github.com/anedyaio/anedya-go-sdk/errors"
)

// REQUEST
// GetLogsRequest represents the payload used to fetch
// log entries for a specific node within a given time range.
type GetLogsRequest struct {
	// NodeID is the unique identifier of the node
	// whose logs are to be retrieved.
	NodeID string `json:"nodeid"`

	// From represents the start timestamp (Unix epoch in milliseconds)
	// from which logs should be fetched.
	From int64 `json:"from"`

	// To represents the end timestamp (Unix epoch in milliseconds).
	// If omitted, logs are fetched up to the latest available entry.
	To int64 `json:"to,omitempty"`

	// Order defines the sorting order of logs.
	// Allowed values: "asc" or "desc".
	Order string `json:"order,omitempty"`

	// Limit specifies the maximum number of log entries to return.
	// Maximum allowed value is 1000.
	Limit int `json:"limit,omitempty"`
}

// DATA MODELS
// LogEntry represents a single log record
// generated by a node.
type LogEntry struct {
	// Timestamp indicates when the log entry was generated
	// (Unix epoch in milliseconds).
	Timestamp int64 `json:"timestamp"`

	// Log contains the log message.
	Log string `json:"log"`
}

// RESPONSE

// GetLogsResponse represents the response returned by
// the Get Logs API.
type GetLogsResponse struct {
	// BaseResponse contains common API response fields
	// such as success status and error information.
	common.BaseResponse

	// Count represents the number of log entries returned.
	Count int `json:"count"`

	// Data contains the list of log entries.
	Data []LogEntry `json:"data"`
}

// GetLogs retrieves log entries for a given node within
// a specified time range.
//
// Steps performed by this method:
//  1. Validate request parameters and constraints.
//  2. Marshal the request payload into JSON.
//  3. Build and execute a POST request to the Logs API.
//  4. Decode the API response into GetLogsResponse.
//  5. Convert API-level failures into structured SDK errors.
//
// Parameters:
//   - ctx: Context used to control request lifecycle, cancellation, and deadlines.
//   - req: Pointer to GetLogsRequest containing log query parameters.
//
// Returns:
//   - (*GetLogsResponse, nil) if logs are fetched successfully.
//   - (nil, error) for validation or client-side failures.
//   - (*GetLogsResponse, error) when the API responds with an error.
func (dm *DeviceLogManagement) GetLogs(ctx context.Context, req *GetLogsRequest) (*GetLogsResponse, error) {

	// validate request object
	if req == nil {
		return nil, &errors.AnedyaError{
			Message: "get logs request cannot be nil",
			Err:     errors.ErrRequestNil,
		}
	}

	// node ID must be provided
	if req.NodeID == "" {
		return nil, &errors.AnedyaError{
			Message: "nodeid is required",
			Err:     errors.ErrInvalidNodeID,
		}
	}

	// from timestamp must be valid
	if req.From <= 0 {
		return nil, &errors.AnedyaError{
			Message: "from timestamp must be valid",
			Err:     errors.ErrInvalidTimeRange,
		}
	}

	// validate time range
	if req.To != 0 && req.To < req.From {
		return nil, &errors.AnedyaError{
			Message: "invalid from/to timestamp range",
			Err:     errors.ErrInvalidTimeRange,
		}
	}

	// validate limit bounds
	if req.Limit < 0 || req.Limit > 1000 {
		return nil, &errors.AnedyaError{
			Message: "limit must be between 0 and 1000",
			Err:     errors.ErrInvalidTimeRange,
		}
	}

	// validate order value
	if req.Order != "" && req.Order != "asc" && req.Order != "desc" {
		return nil, &errors.AnedyaError{
			Message: "order must be asc or desc",
			Err:     errors.ErrInvalidOrder,
		}
	}

	// build API URL
	url := fmt.Sprintf("%s/v1/logs/getLogs", dm.baseURL)

	// encode request body
	body, err := json.Marshal(req)
	if err != nil {
		return nil, &errors.AnedyaError{
			Message: "failed to encode GetLogs request",
			Err:     errors.ErrRequestEncodeFailed,
		}
	}

	// create HTTP request
	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(body))
	if err != nil {
		return nil, &errors.AnedyaError{
			Message: "failed to build GetLogs request",
			Err:     errors.ErrRequestBuildFailed,
		}
	}

	// execute HTTP request
	resp, err := dm.httpClient.Do(httpReq)
	if err != nil {
		return nil, &errors.AnedyaError{
			Message: "failed to execute GetLogs request",
			Err:     errors.ErrRequestFailed,
		}
	}
	defer resp.Body.Close()

	// decode API response
	var apiResp GetLogsResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return nil, &errors.AnedyaError{
			Message: "failed to decode GetLogs response",
			Err:     errors.ErrResponseDecodeFailed,
		}
	}

	// Handle HTTP-level errors.
	if resp.StatusCode < http.StatusOK || resp.StatusCode >= http.StatusMultipleChoices {
		return nil, errors.GetError(apiResp.ReasonCode, apiResp.Error)
	}

	// Handle API-level errors.
	if !apiResp.Success {
		return nil, errors.GetError(apiResp.ReasonCode, apiResp.Error)
	}

	return &apiResp, nil
}
